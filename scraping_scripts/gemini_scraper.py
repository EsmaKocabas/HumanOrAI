"""Gemini API kullanarak AI abstract'larÄ± Ã¼retir."""

import argparse
import csv
import os
import random
import re
import sys
import time
from typing import Dict, List, Optional

import google.generativeai as genai
from dotenv import load_dotenv

# .env dosyasÄ±nÄ± yÃ¼kle
load_dotenv()

DEFAULT_LICENSE = "AI-generated content for research purposes"
BATCH_SIZE = 20  # Her istekte 20 kayÄ±t kaydedilsin
DELAY_BETWEEN_REQUESTS = (1.0, 2.0)  # Rate limiting iÃ§in bekleme
SAVE_INTERVAL = 20  # Her 20 saniyede bir kaydet (kesilme durumunda)
ABSTRACTS_PER_REQUEST = 10  # Tek bir API isteÄŸi ile abstract yeniden yazÄ±lacak (timeout'u Ã¶nlemek iÃ§in)
MAX_RETRIES = 3  # Her istek iÃ§in maksimum deneme sayÄ±sÄ±
REQUEST_TIMEOUT = 120  # API isteÄŸi timeout (saniye)

# Abstract Ã¼retmek iÃ§in kullanÄ±lacak kategoriler
RESEARCH_CATEGORIES = [
    "machine learning", "artificial intelligence", "computer vision", 
    "natural language processing", "deep learning", "neural networks",
    "data science", "statistics", "optimization", "algorithms",
    "computer science", "robotics", "signal processing", "cryptography"
]

# Abstract uzunluk aralÄ±klarÄ± (gerÃ§ekÃ§i olmasÄ± iÃ§in)
ABSTRACT_LENGTHS = [
    "150-200 words",
    "200-250 words", 
    "250-300 words",
    "300-350 words",
    "350-400 words"
]


def wait(delay_range: tuple[float, float]) -> None:
    """Rastgele bir sÃ¼re bekler."""
    time.sleep(random.uniform(*delay_range))


def rewrite_abstracts(gen_model, human_abstracts: List[str], count: int = ABSTRACTS_PER_REQUEST, retry_count: int = 0) -> List[str]:
    """Human abstract'larÄ±nÄ± AI tarafÄ±ndan yeniden yazdÄ±rÄ±r (aynÄ± iÃ§erik, farklÄ± yazÄ±m stili) - retry mekanizmasÄ± ile."""
    
    # Her abstract iÃ§in farklÄ± yazÄ±m stilleri
    styles = [
        "more formal and technical",
        "more concise and direct",
        "with different sentence structures",
        "using alternative terminology",
        "with varied phrasing"
    ]
    
    # Abstract'larÄ± formatla
    abstracts_text = ""
    for i, abstract in enumerate(human_abstracts[:count]):
        abstracts_text += f"Original Abstract {i+1}:\n{abstract}\n\n"
    
    styles_text = ", ".join([f"{i+1}. {styles[i % len(styles)]}" for i in range(count)])
    
    prompt = f"""Rewrite the following {count} academic paper abstracts. Keep the SAME technical content, research findings, and meaning, but change the WRITING STYLE to make them sound like they were written by an AI language model.

CRITICAL REQUIREMENTS:
- Keep ALL technical details, methodologies, and findings EXACTLY THE SAME
- Only change the WRITING STYLE and PHRASING
- Make each rewritten abstract sound like it was generated by an AI (more formulaic, slightly different word choices, different sentence structures)
- Maintain the same length and technical depth
- Do NOT change the research content, only the expression

For each abstract, vary the style: {styles_text}

{abstracts_text}

Rewrite each abstract maintaining the same content but with AI-like writing style. Number them as "Rewritten Abstract 1:", "Rewritten Abstract 2:", etc."""

    try:
        # API isteÄŸi (timeout retry mekanizmasÄ± ile halledilecek)
        response = gen_model.generate_content(prompt)
        
        text = response.text.strip()
        
        # Abstract'larÄ± parse et
        abstracts = []
        
        # "Rewritten Abstract 1:", "Rewritten Abstract 2:" formatÄ±nÄ± ara
        parts = re.split(r'Rewritten\s+Abstract\s+\d+[:\-]?\s*', text, flags=re.IGNORECASE)
        if len(parts) > 1:
            parts = [p.strip() for p in parts[1:] if p.strip()]
        else:
            parts = re.split(r'Abstract\s+\d+[:\-]?\s*', text, flags=re.IGNORECASE)
            if len(parts) > 1:
                parts = [p.strip() for p in parts[1:] if p.strip()]
            else:
                parts = re.split(r'\n\s*\d+[\.\)]\s*', text)
                if len(parts) > 1:
                    parts = [p.strip() for p in parts[1:] if p.strip()]
                else:
                    parts = [p.strip() for p in text.split('\n\n') if p.strip() and len(p.strip()) > 100]
        
        for part in parts:
            if not part:
                continue
            abstract = part.replace('"""', '').strip()
            abstract = abstract.replace("Rewritten Abstract:", "").strip()
            abstract = abstract.replace("Abstract:", "").strip()
            abstract = abstract.replace("ABSTRACT:", "").strip()
            
            if len(abstract) < 100:
                continue
            words = abstract.split()
            if len(words) > 400:
                abstract = " ".join(words[:400])
            abstracts.append(abstract)
        
        if not abstracts and len(text) > 100:
            abstract = text.replace('"""', '').strip()
            words = abstract.split()
            if len(words) > 400:
                abstract = " ".join(words[:400])
            abstracts.append(abstract)
        
        return abstracts
        
    except Exception as exc:
        error_msg = str(exc)
        if retry_count < MAX_RETRIES:
            wait_time = (5 + retry_count * 5, 10 + retry_count * 5)
            print(f"âš  Ä°stek {retry_count + 1}/{MAX_RETRIES} baÅŸarÄ±sÄ±z: {error_msg[:80]}")
            print(f"   {wait_time[0]:.0f}-{wait_time[1]:.0f} saniye bekleniyor...")
            wait(wait_time)
            return rewrite_abstracts(gen_model, human_abstracts, count, retry_count + 1)
        else:
            print(f"âŒ Ä°stek {MAX_RETRIES} denemeden sonra baÅŸarÄ±sÄ±z: {error_msg[:100]}")
            return []


def load_human_abstracts(human_csv_path: str) -> List[str]:
    """Human abstract'larÄ±nÄ± CSV'den yÃ¼kler."""
    abstracts = []
    if not os.path.exists(human_csv_path):
        print(f"âš  Human abstract dosyasÄ± bulunamadÄ±: {human_csv_path}")
        return abstracts
    
    try:
        with open(human_csv_path, "r", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            for row in reader:
                if row.get("label") == "Human":
                    abstract = row.get("abstract_text", "").strip()
                    if abstract and len(abstract) > 50:
                        abstracts.append(abstract)
        # Sessiz yÃ¼kleme
        return abstracts
    except Exception as exc:
        print(f"âš  Human abstract dosyasÄ± okuma hatasÄ±: {exc}")
        return abstracts


def load_existing_count(path: str) -> int:
    """Mevcut CSV dosyasÄ±ndan kayÄ±t sayÄ±sÄ±nÄ± yÃ¼kler."""
    if not os.path.exists(path):
        return 0
    
    try:
        with open(path, "r", encoding="utf-8") as f:
            reader = csv.DictReader(f)
            count = sum(1 for row in reader if row.get("label") == "AI")
            return count
    except Exception as exc:
        print(f"âš  Mevcut dosya okuma hatasÄ±: {exc}")
        return 0


def write_csv(path: str, rows: List[Dict[str, str]]) -> None:
    """KayÄ±tlarÄ± CSV dosyasÄ±na yazar."""
    os.makedirs(os.path.dirname(path), exist_ok=True)
    exists = os.path.exists(path)
    mode = "a" if exists else "w"
    
    with open(path, mode, newline="", encoding="utf-8") as f:
        writer = csv.DictWriter(f, ["abstract_text", "source_url", "license_info", "label"])
        if not exists:
            writer.writeheader()
        writer.writerows(rows)


def generate_ai_abstracts(output: str, target: int, human_csv_path: str = "data/raw/human_abstracts.csv") -> None:
    """Gemini API kullanarak AI abstract'larÄ± Ã¼retir."""
    api_key = os.getenv("GEMINI_API_KEY")
    
    if not api_key:
        print("âŒ GEMINI_API_KEY bulunamadÄ±!")
        sys.exit(1)
    
    # Gemini API'yi yapÄ±landÄ±r
    genai.configure(api_key=api_key)
    
    # Model seÃ§imi - gÃ¼ncel model adlarÄ± (mevcut modellerden)
    model = None
    model_names = [
        'gemini-2.5-flash',        # En gÃ¼ncel flash model (2025)
        'gemini-flash-latest',      # Latest flash model
        'gemini-2.0-flash',        # Flash 2.0
        'gemini-pro-latest',        # Latest pro model
        'gemini-2.5-pro',           # Pro 2.5
    ]
    
    for model_name in model_names:
        try:
            model = genai.GenerativeModel(model_name)
            print(f"âœ… Model: {model_name}")
            break
        except Exception as exc:
            continue
    
    if model is None:
        try:
            available_models = [m.name.replace('models/', '') for m in genai.list_models() 
                              if 'generateContent' in m.supported_generation_methods]
            if available_models:
                model_name = available_models[0].replace('models/', '')
                model = genai.GenerativeModel(model_name)
                print(f"âœ… Model: {model_name}")
        except Exception as e:
            print(f"âŒ Model yÃ¼klenemedi: {e}")
            sys.exit(1)
    
    # Human abstract'larÄ±nÄ± yÃ¼kle
    human_abstracts = load_human_abstracts(human_csv_path)
    
    if not human_abstracts:
        print("âŒ Human abstract'larÄ± yÃ¼klenemedi!")
        sys.exit(1)
    
    existing_count = load_existing_count(output)
    current_total = existing_count
    
    if current_total >= target:
        print(f"âœ… {current_total}/{target} AI kayÄ±t mevcut")
        return
    
    # KaÃ§ human abstract'Ä± iÅŸlememiz gerekiyor?
    needed_human_count = min(target - current_total, len(human_abstracts))
    human_abstracts_to_process = human_abstracts[:needed_human_count]
    
    # Zaman tahmini
    requests_needed = (needed_human_count + ABSTRACTS_PER_REQUEST - 1) // ABSTRACTS_PER_REQUEST
    estimated_minutes = (requests_needed * 5.0) / 60  # Her istek ~5 saniye (timeout dahil)
    
    print(f"ğŸš€ BaÅŸlatÄ±lÄ±yor: {needed_human_count} abstract")
    print(f"ğŸ“Š {requests_needed} istek gerekecek (~{estimated_minutes:.0f} dakika, max 2 saat)")
    print(f"âš™ï¸  Ayarlar: {ABSTRACTS_PER_REQUEST} abstract/istek, {MAX_RETRIES} retry, {REQUEST_TIMEOUT}s timeout")
    print("-" * 60)
    
    buffer: List[Dict[str, str]] = []
    last_save = time.time()
    request_count = 0
    failed_count = 0

    try:
        human_index = 0  # Ä°ÅŸlenecek human abstract'larÄ±n indeksi
        
        while current_total < target and human_index < len(human_abstracts_to_process):
            # KaÃ§ abstract gerekiyor?
            needed = min(ABSTRACTS_PER_REQUEST, target - current_total, len(human_abstracts_to_process) - human_index)
            
            # Ä°ÅŸlenecek human abstract'larÄ± al
            batch_human_abstracts = human_abstracts_to_process[human_index:human_index + needed]
            
            # Ä°stek baÅŸlangÄ±cÄ± log
            print(f"ğŸ“¤ Ä°stek #{request_count + 1}: {needed} abstract iÅŸleniyor...", end=" ", flush=True)
            start_time = time.time()
            
            # Tek bir API isteÄŸi ile birden fazla abstract'Ä± yeniden yaz (aynÄ± iÃ§erik, farklÄ± stil)
            ai_abstracts = rewrite_abstracts(model, batch_human_abstracts, count=needed)
            elapsed = time.time() - start_time
            
            wait(DELAY_BETWEEN_REQUESTS)
            request_count += 1
            human_index += needed
            
            if not ai_abstracts:
                failed_count += 1
                print(f"âŒ BaÅŸarÄ±sÄ±z ({elapsed:.1f}s)")
                if failed_count > 5:
                    print(f"âš  {failed_count} ardÄ±ÅŸÄ±k hata! 10 saniye bekleniyor...")
                    wait((10, 15))
                    failed_count = 0
                continue
            
            # BaÅŸarÄ±lÄ± istek log
            parsed_count = len(ai_abstracts)
            print(f"âœ… {parsed_count}/{needed} abstract alÄ±ndÄ± ({elapsed:.1f}s)")
            
            # Her AI abstract iÃ§in kayÄ±t oluÅŸtur
            added_count = 0
            for ai_abstract in ai_abstracts:
                if current_total >= target:
                    break
                    
                record = {
                    "abstract_text": ai_abstract,
                    "source_url": "https://ai-generated-content/research/abstract",
                    "license_info": DEFAULT_LICENSE,
                    "label": "AI",
                }
                
                buffer.append(record)
                current_total += 1
                added_count += 1
            
            # Her istekte ilerleme gÃ¶ster
            progress_pct = (current_total * 100) // target
            remaining = target - current_total
            print(f"   ğŸ“Š Ä°lerleme: {current_total}/{target} ({progress_pct}%) | Kalan: {remaining} | Ä°stek: {request_count}")
            
            failed_count = 0  # BaÅŸarÄ±lÄ± istek sonrasÄ± reset
            
            # Her BATCH_SIZE kayÄ±tta veya SAVE_INTERVAL saniyede bir kaydet
            if len(buffer) >= BATCH_SIZE or (time.time() - last_save) > SAVE_INTERVAL:
                write_csv(output, buffer)
                buffer.clear()
                last_save = time.time()
    
    except KeyboardInterrupt:
        print("\nâš  Durduruldu")
    except Exception as exc:
        print(f"\nâŒ Hata: {exc}")
        import traceback
        traceback.print_exc()
    finally:
        if buffer:
            write_csv(output, buffer)

    print(f"âœ… TamamlandÄ±: {min(current_total, target)}/{target} ({request_count} istek)")


def main() -> None:
    """Ana fonksiyon."""
    parser = argparse.ArgumentParser(description="Gemini API ile Human abstract'larÄ±nÄ± AI tarzÄ±nda yeniden yazar")
    parser.add_argument("--output", default="data/raw/ai_abstracts.csv", help="Ã‡Ä±ktÄ± CSV dosyasÄ±")
    parser.add_argument("--human-input", default="data/raw/human_abstracts.csv", help="Human abstract CSV dosyasÄ±")
    parser.add_argument("--target", type=int, default=3000, help="Hedef kayÄ±t sayÄ±sÄ±")
    parser.add_argument("--reset", action="store_true", help="Mevcut AI verilerini sil ve baÅŸtan baÅŸla")
    args = parser.parse_args()
    
    # Reset seÃ§eneÄŸi
    if args.reset and os.path.exists(args.output):
        print(f"ğŸ—‘ï¸  Mevcut AI verileri siliniyor: {args.output}")
        os.remove(args.output)
        print(f"âœ… Dosya silindi, baÅŸtan baÅŸlanÄ±yor...")
    
    generate_ai_abstracts(args.output, args.target, args.human_input)


if __name__ == "__main__":
    main()

